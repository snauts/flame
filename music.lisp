(defparameter *notes*
  '((C  0) (Cs 1) (D  2)  (Ds 3)
    (E  4) (F  5) (Fs 6)  (G  7)
    (Gs 8) (A  9) (As 10) (B 10)))

(defparameter *johnny*
  '((2 (0 0 D))
    (2 (0 0 G)  (4 0 D) (5 0 G) (6 0 As))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 A))
    (4 (0 0 As) (4 0 D) (5 0 G) (6 0 As))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 0 G))
    (6 (0 0 F)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 D))
    (6 (0 0 F)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 D))
    (2 (0 0 G)  (4 0 D) (5 0 G))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 A))
    (4 (0 0 As) (4 0 D) (5 0 G))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 1 C))
    (6 (0 1 D)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 As))
    (6 (0 1 D)  (4 0 D) (5 0 F) (6 0 As))
    (2                  (5 0 F))
    (2 (0 0 As))
    (2 (0 1 C))
    (4 (0 1 D)  (4 0 D) (5 0 F))
    (2 (0 1 D))
    (2 (0 1 D))
    (2 (0 1 C))
    (2 (0 0 As))
    (4 (0 1 C)  (4 0 C) (5 0 Ds) (6 0 G))
    (2 (0 1 C))
    (2 (0 1 C))
    (2 (0 0 As))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 0 As))
    (2 (0 0 As))
    (2 (0 0 A))
    (2 (0 0 G))
    (4 (0 0 A))
    (2 (0 0 A))
    (2 (0 0 A))
    (2 (0 0 As))
    (2 (0 1 C))
    (6 (0 1 D))
    (6 (0 1 C))
    (6 (0 0 As))
    (6 (0 0 A))
    (2 (0 0 G))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 F))
    (10(0 0 G))))

(defun save-bytes (out bytes)
  (let ((count 0))
    (dolist (b bytes)
      (format out "0x~2,'0X, " b)
      (when (>= (incf count) 8)
	(format out "~%")
	(setf count 0)))
    (when (/= count 0)
      (format out "~%"))))

(defun save-array (out name bytes)
  (format out "const byte ~A[] = {~%" name)
  (save-bytes out bytes)
  (format out "};~%"))

(defun bit-n (x)
  (ash 1 x))

(defun select-channels (chord)
  (reduce #'logior (mapcar #'bit-n (mapcar #'first (rest chord)))))

(defun note-to-byte (note)
  (logior (second (assoc (third note) *notes*))
	  (ash (second note) 4)))

(defun is-key-off (note)
  (eq 'X (third note)))

(defun lookup-note (note)
  (if (not (is-key-off note))
      (note-to-byte note)
      (bit-n 7)))

(defun sort-chord (chord)
  (sort (copy-list chord) #'< :key #'first))

(defun save-score (score)
  (let ((result nil))
    (dolist (chord score)
      (push (select-channels chord) result)
      (dolist (note (sort-chord (rest chord)))
	(push (lookup-note note) result))
      (push (first chord) result))
    (push 0 result)
    (reverse result)))

(defun scale-chord (chord amount)
  (setf (first chord) (* amount (first chord))))

(defun scale-tempo (score amount)
  (mapc (lambda (chord) (scale-chord chord amount)) score))

(defun adjust-note (score data adjust-fn)
  (dolist (chord score)
    (dolist (note (rest chord))
      (funcall adjust-fn note data))))

(defun adjust-note-octaves (note octaves)
  (setf (second note) (+ (second note) (elt octaves (first note)))))

(defun adjust-octaves (score octaves)
  (adjust-note score octaves #'adjust-note-octaves))

(defun clean-up-score (score &optional prev)
  (unless (null score)
    (let ((head (first score)))
      (cond ((and prev (null (rest head)))
	     (incf (first (first prev)) (first head))
	     (setf (rest prev) (rest score))
	     (clean-up-score (rest score) prev))
	    (t (clean-up-score (rest score) score))))))

(defun copy-score (score)
  (copy-tree score))

(defun remove-channel (chord channel &key (test #'=))
  (setf (rest chord) (remove channel (rest chord) :key #'first :test test)))

(defun isolate-channel (score channel)
  (mapc (lambda (chord) (remove-channel chord channel :test #'/=)) score))

(defun key-off-all-score (score)
  (adjust-note score 'X (lambda (note data) (setf (third note) data))))

(defun rename-channels (score channel)
  (adjust-note score channel (lambda (note data) (setf (first note) data))))

(defun offset-score (score offset)
  (setf (rest score) (cons (first score) (rest score)))
  (setf (first score) (list offset)))

(defun divide-interval (score offset)
  (let ((interval (first (first score))))
    (cond ((< offset interval)
	   (setf (first (first score)) offset)
	   (setf (rest score) (cons (list (- interval offset)) (rest score))))
	  (t (error "divide offset larger than interval")))))

(defun consistency (notes)
  (unless (equal notes (remove-duplicates notes :key #'first))
    (error "inconsistent notes during merge~%~A" notes))
  notes)

(defun merge-chords (dst src)
  (cons (first dst) (consistency (append (rest dst) (rest src)))))

(defun merge-heads (dst src)
  (setf (first dst) (merge-chords (first dst) (first src))))

(defun merge-into (dst src)
  (let ((i (first (first dst)))
	(j (first (first src))))
    (when (> i j)
      (divide-interval dst j))
    (when (< i j)
      (divide-interval src i))
    (merge-heads dst src)
    (cond ((null (rest src)))
	  ((null (rest dst))
	   (setf (rest dst) (rest src)))
	  (t (merge-into (rest dst) (rest src))))))

(defun copy-channel (score src dst)
  (let ((tmp (copy-score score)))
    (isolate-channel tmp src)
    (rename-channels tmp dst)
    (merge-into score tmp)))

(defun channel-key-off (score channel interval)
  (let ((tmp (copy-score score)))
    (isolate-channel tmp channel)
    (offset-score tmp interval)
    (key-off-all-score tmp)
    (merge-into score tmp)))

(defun johnny-score ()
  (let ((score (copy-score *johnny*)))
    (copy-channel score 0 1)
    (copy-channel score 0 2)
    (channel-key-off score 2 1)
    (adjust-octaves score '(1 2 0 x 0 0 0))
    (scale-tempo score 5)
    (clean-up-score score)
    score))

(defun save-music ()
  (with-open-file (out "music.inc" :if-exists :supersede :direction :output)
    (save-array out "johnny_score" (save-score (johnny-score)))))

(defun save-and-quit ()
  (handler-case (save-music)
    (condition (var) (format t "ERROR: ~A~%" var)))
  (quit))
