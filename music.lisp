(defparameter *notes*
  '((C  617) (Cs 653) (D  692)  (Ds 733)
    (E  777) (F  823) (Fs 872)  (G  924)
    (Gs 979) (A 1037) (As 1099) (B 1164)))

(defparameter *octaves* '(0 1 4 x 0 0 0))
(defparameter *tempo* 5)

(defparameter *johnny*
  '((2 (0 0 D))
    (2 (0 0 G)  (4 0 D) (5 0 G) (6 0 As))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 A))
    (4 (0 0 As) (4 0 D) (5 0 G) (6 0 As))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 0 G))
    (6 (0 0 F)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 D))
    (6 (0 0 F)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 D))
    (2 (0 0 G)  (4 0 D) (5 0 G))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 A))
    (4 (0 0 As) (4 0 D) (5 0 G))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 1 C))
    (6 (0 1 D)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 As))
    (6 (0 1 D)  (4 0 D) (5 0 F) (6 0 As))
    (2                  (5 0 F))
    (2 (0 0 As))
    (2 (0 1 C))
    (4 (0 1 D)  (4 0 D) (5 0 F))
    (2 (0 1 D))
    (2 (0 1 D))
    (2 (0 1 C))
    (2 (0 0 As))
    (4 (0 1 C)  (4 0 C) (5 0 Ds) (6 0 G))
    (2 (0 1 C))
    (2 (0 1 C))
    (2 (0 0 As))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 0 As))
    (2 (0 0 As))
    (2 (0 0 A))
    (2 (0 0 G))
    (4 (0 0 A))
    (2 (0 0 A))
    (2 (0 0 A))
    (2 (0 0 As))
    (2 (0 1 C))
    (6 (0 1 D))
    (6 (0 1 C))
    (6 (0 0 As))
    (6 (0 0 A))
    (2 (0 0 G))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 F))
    (10(0 0 G))))

(defun save-bytes (out bytes)
  (let ((count 0))
    (dolist (b bytes)
      (format out "0x~2,'0X, " b)
      (when (>= (incf count) 8)
	(format out "~%")
	(setf count 0)))
    (when (/= count 0)
      (format out "~%"))))

(defun save-array (out name bytes)
  (format out "const byte ~A[] = {~%" name)
  (save-bytes out bytes)
  (format out "};~%"))

(defun bit-n (x)
  (ash 1 x))

(defun select-channels (chord)
  (reduce #'logior (mapcar #'bit-n (mapcar #'first (rest chord)))))

(defun lookup-note (note)
  (let ((octave (+ (elt *octaves* (first note)) (second note)))
	(frequency (second (assoc (third note) *notes*))))
    (list (logior (ash frequency -8) (ash octave 3))
	  (logand frequency #xff))))

(defun sort-chord (chord)
  (sort (copy-list chord) #'< :key #'first))

(defun save-score (score)
  (let ((result nil))
    (dolist (chord score)
      (push (select-channels chord) result)
      (dolist (note (sort-chord (rest chord)))
	(dolist (x (lookup-note note))
	  (push x result)))
      (push (* (first chord) *tempo*) result))
    (push 0 result)
    (reverse result)))

(defun add-note (chord i new)
  (let ((note (assoc i (rest chord))))
    (and note (list (cons new (copy-list (rest note)))))))

(defun duplicate-channel (score i new)
  (mapcar (lambda (chord) (append chord (add-note chord i new))) score))

(defun johnny-score ()
  (let ((pass1 (duplicate-channel *johnny* 0 1)))
    (duplicate-channel pass1 0 2)))

(defun save-music ()
  (with-open-file (out "music.inc" :if-exists :supersede :direction :output)
    (save-array out "johnny_score" (save-score (johnny-score)))))

(defun save-and-quit ()
  (save-music)
  (quit))
