(defparameter *notes*
  '((C  617) (Cs 653) (D  692)  (Ds 733)
    (E  777) (F  823) (Fs 872)  (G  924)
    (Gs 979) (A 1037) (As 1099) (B 1164) (X -1)))

(defparameter *octaves* '(0 1 2 x 0 0 0))

(defparameter *johnny*
  '((2 (0 0 D))
    (2 (0 0 G)  (4 0 D) (5 0 G) (6 0 As))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 A))
    (4 (0 0 As) (4 0 D) (5 0 G) (6 0 As))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 0 G))
    (6 (0 0 F)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 D))
    (6 (0 0 F)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 D))
    (2 (0 0 G)  (4 0 D) (5 0 G))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 A))
    (4 (0 0 As) (4 0 D) (5 0 G))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 1 C))
    (6 (0 1 D)  (4 0 D) (5 0 F) (6 0 As))
    (4                  (5 0 F))
    (2 (0 0 As))
    (6 (0 1 D)  (4 0 D) (5 0 F) (6 0 As))
    (2                  (5 0 F))
    (2 (0 0 As))
    (2 (0 1 C))
    (4 (0 1 D)  (4 0 D) (5 0 F))
    (2 (0 1 D))
    (2 (0 1 D))
    (2 (0 1 C))
    (2 (0 0 As))
    (4 (0 1 C)  (4 0 C) (5 0 Ds) (6 0 G))
    (2 (0 1 C))
    (2 (0 1 C))
    (2 (0 0 As))
    (2 (0 0 A))
    (4 (0 0 As))
    (2 (0 0 As))
    (2 (0 0 As))
    (2 (0 0 A))
    (2 (0 0 G))
    (4 (0 0 A))
    (2 (0 0 A))
    (2 (0 0 A))
    (2 (0 0 As))
    (2 (0 1 C))
    (6 (0 1 D))
    (6 (0 1 C))
    (6 (0 0 As))
    (6 (0 0 A))
    (2 (0 0 G))
    (2 (0 0 G))
    (2 (0 0 G))
    (4 (0 0 G))
    (2 (0 0 F))
    (10(0 0 G))))

(defun save-bytes (out bytes)
  (let ((count 0))
    (dolist (b bytes)
      (format out "0x~2,'0X, " b)
      (when (>= (incf count) 8)
	(format out "~%")
	(setf count 0)))
    (when (/= count 0)
      (format out "~%"))))

(defun save-array (out name bytes)
  (format out "const byte ~A[] = {~%" name)
  (save-bytes out bytes)
  (format out "};~%"))

(defun bit-n (x)
  (ash 1 x))

(defun select-channels (chord)
  (reduce #'logior (mapcar #'bit-n (mapcar #'first (rest chord)))))

(defun lookup-note (note)
  (let ((octave (+ (elt *octaves* (first note)) (second note)))
	(frequency (second (assoc (third note) *notes*))))
    (if (< frequency 0)
	(list (bit-n 7) 0)
	(list (logior (ash frequency -8) (ash octave 3))
	      (logand frequency #xff)))))

(defun sort-chord (chord)
  (sort (copy-list chord) #'< :key #'first))

(defun save-score (score)
  (let ((result nil))
    (dolist (chord score)
      (push (select-channels chord) result)
      (dolist (note (sort-chord (rest chord)))
	(dolist (x (lookup-note note))
	  (push x result)))
      (push (first chord) result))
    (push 0 result)
    (reverse result)))

(defun new-note (new old-note)
  (cons new (copy-list (rest old-note))))

(defun find-note (channel chord)
  (assoc channel (rest chord)))

(defun add-note (chord old new)
  (let ((note (find-note old chord)))
    (when (and note (null (find-note new chord)))
      (setf (rest (last chord)) (list (new-note new note))))))

(defun duplicate-channel (score old new)
  (mapc (lambda (chord) (add-note chord old new)) score))

(defun scale-chord (chord amount)
  (setf (first chord) (* amount (first chord))))

(defun scale-tempo (score amount)
  (mapc (lambda (chord) (scale-chord chord amount)) score))

(defun johnny-score ()
  (let ((score (copy-tree *johnny*)))
    (duplicate-channel score 0 1)
    (duplicate-channel score 0 2)
    (scale-tempo score 5)
    score))

(defun save-music ()
  (with-open-file (out "music.inc" :if-exists :supersede :direction :output)
    (save-array out "johnny_score" (save-score (johnny-score)))))

(defun save-and-quit ()
  (save-music)
  (quit))
